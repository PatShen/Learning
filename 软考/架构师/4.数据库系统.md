```
SQL 语句
SELECT
GRANT
GROUP BY
```

```
了解集中式数据库体系结构，了解分布式数据库的体系结构及分布式的相关特性。
了解数据库设计过程，了解概念结构设计的基本过程和冲突的分析解决，了解逻辑结构设计的基本过程和关系模式向关的基本概念。
掌握关系代数运算。
了解规范化理论相关基本概念，掌握候选码、范式、模式分解的分析。
了解数据库安全相关措施、了解数据库并发控制、完整性相关概念，了解数据库备份与故障恢复的相关概念和分类。
```
上午：4'

# 数据库概述 1'
## 数据库模式
> 比较理想化，实际使用不多。纯概念考察

三级模式
* 内模式：文件级别（存储模式）
* 概念模式：表级别（逻辑模式）
* 外模式：视图级别（用户模式）

两级映射关系，分别保障了数据的独立性：
* 逻辑独立性
* 物理独立性

聚簇索引
* 会修改存储顺序，会影响内模式

## 分布式数据库
> 多个物理节点存放数据库（数据在多个物理节点存放）
>
> 副本，冗余提高，也提高可用性、数据持久性。
>
> 提高性能：多副本可读，就近读取

* 可用性：当一个节点故障，其他节点依旧可用。系统整体仍然可用
* 自治性：每个节点可以自己管理自己，具有局部数据库
* 共享性：节点之间共享数据
* 分布性：不同场地存储

* 全局概念模式：数据库的逻辑结构（也可以叫做全局逻辑模式）
* 全局外模式：应用程序直接调用的部分
* 分片模式
  * 水平分片：满足某筛选条件的数据，放在同一个物理节点上
  * 垂直分片：核心字段放在一个节点，其他字段放在其他节点
* 分布模式
  * 考虑把分片放到哪里
  * 副本机制
 
* 数据独立性
* 集中与自治共享结合的控制结构
* 适当增加数据冗余度
* 全局的一致性、可串性和可恢复性

### 透明性分类
> 透明性：用户不关心

* 分片透明：不关心数据分不分片、怎么分片
* 位置透明：不关心数据存放在何处（物理位置）
* 复制透明：不关心各个节点数据的复制与同步更新
* 逻辑透明：不关心局部DBMS支持哪种数据模型、使用哪种语言

> 用户不必关心数据是如何分块存储的：分片透明

```
考点：
1.分布式数据库的特点：分布性、可用性、自治性、共享性
2.分片方式
3.透明性分类
4.体系结构
```

### 两阶段提交协议 2PC

* 2PC事务提交的两个阶段
  * 表决阶段：形成共同的决定
  * 执行阶段，实现前一阶段的决定
* 两条全局提交规则
  * 只要有一个参与者撤销事务，协调者就必须做出`全局撤销`的决定
  * 只有所有参与者都同意提交事务，协调者才能做出`全局提交`的决定


# 数据库设计过程（阶段）1‘

> 考虑当前、未来应用的数据要求（需求），以及数据处理的要求

* 需求分析，产出：
  * 数据流图
  * 数据字典
  * 需求说明书
* 概念结构设计：产物会在后续步骤中使用，对现实世界进行抽象
  * E-R 模型：实体-关系模型（Entity-Relationship）
  * 用户的数据模型：是一种概念模型，与DBMS无关。
* 逻辑结构设计：根据E-R模型转换规则、规范化理论，产出：
  * 数据库表
  * 关系模式：可以直接转化为二维表
    * 例如：学生（姓名，性别，学号...），表名：学生；列名（字段）：姓名、性别、学号。
  * 输出：视图、完整性约束、应用处理说明书给后续步骤
* 物理设计：根据DBMS特性、硬件、OS特性等

## E-R 模型

> 两个实体集之间的关系，1:1，1:n，m:n

## 概念结构设计

集成方法：
* 多个E-R图一次集成
* 逐步集成

冲突&解决办法：
* 属性冲突：属性域冲突和属性取值冲突【同一对象】。协商统一
* 命名冲突：同名异义，异名同义【同一对象】。协商统一
* 结构冲突：同一对象在不同应用中具有不同的抽象；同一实体在不同局部E-R图中所包含的属性个数和排列次序不完全相同。个数不同，一般保留较多的，较少部分进行补充

步骤
* 抽象数据
* 设计局部ER模型
* 合并局部模型，消除冲突
* 重构优化，消除冗余

## 逻辑结构设计

步骤
* 转化为数据模型
* 关系规范化
* 模式优化
* 设计用户子模式

联系在转换时
* `1:1`：可以单独转换，也可以并入任意一端。
* `1:n`：可以单独转换，也可以并入多端
* `m:n`：只能单独转换

* 实体完整性约束：主键，唯一且非空
* 参照完整性约束：外键，要么为空，要么是其他关系的主键

### 关系模式
```
R<U,F>
U：属性集合
F：函数依赖集合
```

* 目或度：关系模式中属性的个数
* 候选码（候选键）：唯一标识元组，且无冗余。可以有多个。
  * 是属性集合，可以有1个或多个。
* 主码（主键）
* 主属性与非主属性：组成候选码的属性就是主属性，其他都是非主属性
* 外码（外键）
* 全码（all-key）：关系模式的所有属性组是这个关系的候选码
* 简单属性与复合属性、派生属性、多值属性
  * 复合属性：地址，拆分成省、市、街道...否则是简单属性
  * 派生属性：可由计算、推导得出的属性
  * 多值属性
 
# 重点
## 集中式数据库
* 三级模式，两级映射，对应：xxx
* 逻辑独立性，物理独立性
* 聚簇索引

## 分布式数据库
* 体系结构，层次划分
* 特点
* 透明性分类
* 分片方式
* 2PC

## 数据库设计
* 了解各个阶段的产物

## 概念结构设计过程
冲突

## 逻辑结构设计过程
完整性分类

## 关系模式的概念

# 关系代数 3'
```
* 运算，并交叉，笛卡尔积，自然连接
* 笛卡尔积和自然连接
* 关系代数与查询语句：`SELECT`, `group by`, `grant`（授权）
* 查询性能
```
> 二维表

```
关系模式的运算
水平：元组行
垂直：属性列，字段
```

## 集合运算
* 并、交、差。
  * 将每一行看作整体。
  * 二元运算符
  * 运算对象和结果同构

一元运算符
* 投影：（派 π）
  * 运算结果的表结构会变化
  * 选择垂直方向
* 选择：（西格玛）
  * 结果的结构不变
  * 选择水平方向上满足条件的项

```
SELECT ... -> （投影）
FROM table_name
WHERE ... -> （选择）
```

## 笛卡尔积
* 二元运算，运算对象、运算结果不要求同构
* 结果的列数为运算对象之和
* 结果的行数为运算对象之积
> 所有列保留，所有行全映射

> 对于同名的属性列，用：`表名.列名`，或用`列序号`表示属性名

## 自然连接

* 二元运算，运算对象不要求同构
* 列数是二者之和减去重复的列数
* 行：同名属性列取值相等

查询性能
* 运算对象先压缩
* 自然连接的性能优于笛卡尔积

# 规范化理论 3'
```
* 属性集合，函数依赖
* 公里体系
* 候选键的判断，主属性、非主属性的判断
* 规范化程度（范式）
* 关系模式分解
```
> 非规范化的关系模式，可能存在的问题：数据冗余，更新异常，插入异常，删除异常。

> X->Y：X函数决定Y，Y函数依赖于X

* 若X->Y, Y->Z 则X->Z：传递律
* 若Y⊆X⊆U，则X->Y：自反律
* 若X->Y，Z⊆Y，则X->Z：分解规则
* 若X->Y，X->Z，则X->YZ：合并规则

## 候选键

* 唯一标识，且无冗余。
* 可以有多个。
* 可以是单属性，也可以是多属性。
* 如果有多个，任选一个作为主键

> 外键：引用其他关系的主键。可以保证参照完整性。
>
> 主键唯一且非空，实体完整性。

* 将关系模式的函数依赖关系用“有向图”的方式表示
* 找入度为0的属性，并以该属性集合为起点，尝试遍历有向图，若能正常遍历图中所有节点，则该属性即为关系模式的候选键
* 若入度为0的属性不能遍历图中所有节点，则需要尝试将一些中间节点（既有入度也有出度）并入入度为0的属性集中，直至该集合能遍历所有节点。则这个集合为候选键。

## 范式
> 层层递进，逐步优化，以解决：插入异常、删除异常、数据冗余。
* 第一范式，1NF：属性都是不可分的原子值
* 2NF：1NF消除非主属性对候选键的部份依赖
* 3NF：2NF消除非主属性对候选键的传递依赖
* BCNF：3NF消除主属性对候选键的部份和传递依赖

> 4NF：是限制关系模式的属性间不允许有非平凡且非函数依赖的`多值依赖`（A->->B)。

## 模式分解
* 保持函数依赖：分解后的函数依赖与分解前等价
```
𝞀={R1, R2, ..., Rk}是关系模式R的一个分解，F是R上的函数依赖集，𝞀中每个模式Ri上的FD集是Fi。如果{F1, F2, ..., Fk}与F是等价的（逻辑蕴含），称分解𝞀保持FD
```
* 无损分解
  * 有损：不能还原
  * 无损：可以还原。将一个关系模式分解成若干个关系模式后，通过自然连接和投影等运算仍能还原到原来的关系模式。
> 如果分解的两个表没有同名属性列，一定有损。（即交集为空，∅）

```
可以推导得出的函数依赖是冗余的函数依赖。在考虑是否保持函数依赖的时候可以忽略。
```

定理：交集->差集
```
如果R的分解𝞀={R1, R2}，F为R所满足的函数依赖集合，分解𝞀具有无损连接性的充分必要条件是：
R1∩R2->(R1-R2)
或 R1∩R2->(R2-R1)
其中R1∩R2表示模式的交，为R1与R2中公共属性组成，R1-R2或R2-R1表示模式的差集，R1-R2表示R1中去除R2的公共属性所组成。当模式R分解成两个关系模式R1和R2时，如果R1与R2的公共属性能函数决定R1或R2中的其他属性，这样的分解就具有无损连接性。
```

# 数据控制 1'
## 安全性
  * 用户标识和鉴定：正确的人，通过正确的方式，访问正确的数据
  * 存取控制：针对某一类对象授予特殊的权限
  * 密码存储和传输：加密存储&传输。数据脱敏（PII数据）
  * 视图的保护：不可修改。
  * 审计：用专门的文件/数据记录用户操作，用于追溯。
## 完整性
  * 实体完整性：主键唯一且非空，主属性不为空
  * 参照完整性：外键是其他关系的主键，或空值。
  * 用户自定义完整性：基于应用环境决定。
  * 触发器：在某个数据对象上添加类似监听，一旦出现变化，联动修改其他数据对象。
## 并发控制
> 并发时，不要破坏数据完整性

### 事务
> ACID

* 原子性
* 一致性
* 隔离性
* 持续性（持久性）

CAP特性
* 一致性
* 可用性
* 分区容忍性

### 并发产生的问题
* 丢失更新
* 不可重复读
* 脏数据的读出

### 解决方案
* 封锁协议
  * S封锁：读锁/共享锁
  * X封锁：写锁/独占锁/排他锁
  * 一级封锁协议：只有写锁，没有读锁
  * 二级：读完立即释放读锁
  * 三级：读完，等到事务结束再释放读锁
  * 两段锁：加锁操作和解锁操作有明显的分隔
 
* 死锁

## 故障恢复

> 需要有副本（备份/转储/冗余）

* 冷备份（静态备份），将数据库正常关闭，在停止状态下，将数据库的文件全部备份下来
  * 优点：快速（只需要复制文件）；容易归档；容易恢复到某个时间点上；能与归档方法相结合，做数据库“最佳状态”的恢复；低维护度，高度安全
  * 缺点：只能提供到某一个时间点上的恢复；在实施备份的全过程中，数据库必须做备份，不能做其他事；若磁盘空间有限，只能复制到磁带等其他外部存储，速度很慢；不能按照表或按用户恢复
* 热备份（动态备份），利用备份软件，在数据库正常运行时，将数据库中的数据文件备份出来
  * 优点：可在表空间或数据库文件级备份，备份时间短；备份时数据库仍可用；可达到秒级恢复；可对几乎所有数据库实体做恢复；恢复快速。
  * 缺点：不能出错，否则后果严重；若不成功，所得结果不可用于时间点的恢复；因难以维护，不允许“以失败结束”。
 
* 完全备份：全量备份。
* 差量备份：仅备份上一次完全备份之后变化了的数据
* 增量备份：备份上一次备份后变化的数据

> 备份的恢复只能恢复到备份节点

* 日志文件：针对数据库变化做记录。

故障关系|故障原因|解决办法
---|---|---
事务本身的可预期故障|本身逻辑|在程序中预先设置rollback语句
事务本身的不可预期故障|算数溢出、违反存储保护|由DBMS的恢复子系统通过日志，撤销事务对数据库的修改，回退到事务初始状态
系统故障|系统停止运转|通常使用检查点法
介质故障|外存被破坏|一般使用日志重做业务

```
日志扫描：从后往前。有commit：redo；没有commit：undo；
```
